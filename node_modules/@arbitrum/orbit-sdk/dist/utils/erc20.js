"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchAllowance = exports.approve = exports.approvePrepareTransactionRequest = void 0;
const viem_1 = require("viem");
const contracts_1 = require("../contracts");
function approveEncodeFunctionData({ spender, amount, }) {
    return (0, viem_1.encodeFunctionData)({
        abi: contracts_1.erc20.abi,
        functionName: 'approve',
        args: [spender, amount],
    });
}
async function approvePrepareTransactionRequest({ address, owner, spender, amount, publicClient, }) {
    return await publicClient.prepareTransactionRequest({
        chain: publicClient.chain,
        to: address,
        data: approveEncodeFunctionData({ spender, amount }),
        value: BigInt(0),
        account: owner,
    });
}
exports.approvePrepareTransactionRequest = approvePrepareTransactionRequest;
async function approve({ address, spender, amount, publicClient, walletClient, }) {
    const account = walletClient.account?.address;
    if (typeof account === 'undefined') {
        throw new Error('[utils/erc20::approve] account is undefined');
    }
    const { request } = await publicClient.simulateContract({
        address: address,
        abi: contracts_1.erc20.abi,
        functionName: 'approve',
        args: [spender, amount],
        account,
    });
    const hash = await walletClient.writeContract(request);
    return await publicClient.waitForTransactionReceipt({ hash: hash });
}
exports.approve = approve;
async function fetchAllowance({ address, owner, spender, publicClient, }) {
    return publicClient.readContract({
        address,
        abi: contracts_1.erc20.abi,
        functionName: 'allowance',
        args: [owner, spender],
    });
}
exports.fetchAllowance = fetchAllowance;
